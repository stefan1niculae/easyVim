// Generated by CoffeeScript 1.10.0
(function() {
  var KeyListener, loadSampleText, suggestCommand,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Function.prototype.property = function(prop, desc) {
    return Object.defineProperty(this.prototype, prop, desc);
  };

  String.prototype.occurrencesOf = function(substr) {
    var i, j, occ, ref;
    occ = 0;
    for (i = j = 0, ref = this.length - substr.length; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      if (this.slice(i).startsWith(substr)) {
        occ++;
      }
    }
    return occ;
  };

  String.prototype.matchesOf = function(regex) {
    var match, source;
    source = regex.source;
    regex = new RegExp(source, "g");
    match = this.match(regex);
    if (match != null) {
      return match.length;
    }
    return 0;
  };

  Array.prototype.containsOnly = function(targets) {
    var elem, j, len;
    for (j = 0, len = this.length; j < len; j++) {
      elem = this[j];
      if (!_.contains(targets, elem)) {
        return false;
      }
    }
    return true;
  };

  Array.prototype.contains = function(target) {
    return _.contains(this, target);
  };

  this.Keys = {
    left: 37,
    right: 39,
    up: 38,
    down: 40,
    mouse: -1
  };

  Keys.directional = [Keys.left, Keys.right, Keys.up, Keys.down, Keys.mouse];

  KeyListener = (function() {
    KeyListener.prototype.MAX_TIME_BETWEEN_STROKES = 750;

    KeyListener.prototype.MIN_MOVEMENT_STROKES = 1;

    KeyListener.prototype.MAX_WORD_MOVEMENT_COUNT = 6;

    KeyListener.prototype.MAX_VERT_MOVEMENT_COUNT = 40;

    KeyListener.prototype.MAX_ANCHOR_MOVEMENT_COUNT = 4;

    KeyListener.property('seqStart', {
      set: function(index) {
        return this._seqStartIndex = index;
      },
      get: function() {
        var lineCol, textToCursor;
        textToCursor = this.elem.text().slice(0, this._seqStartIndex);
        lineCol = this.computeLineCol(textToCursor, this._seqStartIndex);
        return $.extend({
          index: this._seqStartIndex
        }, lineCol);
      }
    });

    KeyListener.property('seqEnd', {
      set: function(index) {
        return this._seqEndIndex = index;
      },
      get: function() {
        var lineCol, textToCursor;
        textToCursor = this.elem.text().slice(0, this._seqEndIndex);
        lineCol = this.computeLineCol(textToCursor, this._seqEndIndex);
        return $.extend({
          index: this._seqEndIndex
        }, lineCol);
      }
    });

    KeyListener.prototype.computeLineCol = function(str, index) {
      var startOfLine;
      startOfLine = str.lastIndexOf('\n');
      return {
        line: 1 + str.occurrencesOf('\n'),
        col: index - startOfLine
      };
    };

    KeyListener.property('elem', {
      get: function() {
        return $(this.selector);
      }
    });

    KeyListener.property('htmlElem', {
      get: function() {
        return this.elem[0];
      }
    });

    KeyListener.property('text', {
      get: function() {
        return this.elem.text();
      }
    });

    function KeyListener(selector) {
      var code, name, self;
      this.selector = selector;
      self = this;
      this.elem.keydown(function() {
        return self.registerKeyDown(event.which);
      }).keyup(function() {
        return self.registerKeyUp(event.which);
      }).mousedown(function() {
        return self.registerMouseDown();
      }).mouseup(function() {
        return self.registerMouseUp();
      });
      this.supportedKeyCodes = [];
      for (name in Keys) {
        code = Keys[name];
        this.supportedKeyCodes.push(code);
      }
      this.currSeq = [];
    }

    KeyListener.prototype.registerKeyDown = function(code) {
      if (indexOf.call(this.supportedKeyCodes, code) < 0) {
        return;
      }
      return this.registerPossibleStart();
    };

    KeyListener.prototype.registerKeyUp = function(code) {
      if (indexOf.call(this.supportedKeyCodes, code) < 0) {
        return;
      }
      this.registerEnd();
      this.currSeq.push(code);
      if (this.timer != null) {
        clearTimeout(this.timer);
      }
      return this.timer = setTimeout(this.processSeq.bind(this), this.MAX_TIME_BETWEEN_STROKES);
    };

    KeyListener.prototype.registerPossibleStart = function() {
      if (this.currSeq.length === 0) {
        return this.seqStart = this.htmlElem.selectionStart;
      }
    };

    KeyListener.prototype.registerEnd = function() {
      return this.seqEnd = this.htmlElem.selectionStart;
    };

    KeyListener.prototype.registerMouseDown = function() {
      return this.registerPossibleStart();
    };

    KeyListener.prototype.registerMouseUp = function() {
      this.registerEnd();
      this.currSeq.push(Keys.mouse);
      return this.processSeq();
    };

    KeyListener.prototype.processSeq = function() {
      var beforeStart, from, last, next, prevRelevant, to, traversed, wentForward;
      wentForward = this.seqEnd.index - this.seqStart.index > 0;
      if (this.seqStart.index === this.seqEnd.index) {
        traversed = '';
      } else {
        if (wentForward) {
          from = this.seqStart.index;
          to = this.seqEnd.index;
        } else {
          from = this.seqEnd.index;
          to = this.seqStart.index;
        }
        traversed = this.text.slice(from, +(to - 1) + 1 || 9e9);
      }

      /*
      When traversing 'abcd' from left to right -->, the letter we stopped at is 'd'
      But traversing it the other way, right to left <--, the letter we stopped at is 'a'
      Same goes for the next char: on left to right direction, the next char is the one to the right of d
      But on right to left direction, the next char is the one before a
       */
      beforeStart = this.text[this.seqStart.index - 1];
      last = wentForward ? traversed.slice(-1) : traversed[0];
      next = wentForward ? this.text[this.seqEnd.index] : this.text[this.seqEnd.index - 1];
      if (this.currSeq.containsOnly(Keys.directional) && ((this.currSeq.contains(Keys.mouse) && traversed.length > 0) || (traversed.length >= this.MIN_MOVEMENT_STROKES && this.currSeq.length >= this.MIN_MOVEMENT_STROKES))) {
        prevRelevant = this.suggestVertMovement(wentForward);
        if (!prevRelevant) {
          prevRelevant = this.suggestHomeEndMovement(next);
        }
        if (!prevRelevant) {
          prevRelevant = this.suggestWordMovement(traversed, wentForward, beforeStart, last, next);
        }
        if (!prevRelevant) {
          this.suggestAnchorMovement(traversed, wentForward);
        }
      }
      this.currSeq = [];
      return this.timer = null;
    };

    KeyListener.prototype.suggestVertMovement = function(wentForward) {

      /*
      From the Vim documentation (online at http://vimdoc.sourceforge.net/htmldoc/motion.html#up-down-motions)
        k       [count] lines upward.
        j			  [count] lines downward.
      
        Remember: J looks a bit like a down arrow so it means go down
                  Also in romanian the word for down starts with J
       */
      var distance, immNext, lineEndCol, lineStartIndex, motion;
      distance = Math.abs(this.seqEnd.line - this.seqStart.line);
      if (distance === 0 || distance > this.MAX_VERT_MOVEMENT_COUNT) {
        return false;
      }
      immNext = this.text[this.seqEnd.index];
      if (this.seqEnd.line === 1) {
        lineEndCol = this.text.indexOf('\n');
      } else {
        lineStartIndex = 1 + this.text.slice(0, +(this.seqEnd.index - 1) + 1 || 9e9).lastIndexOf('\n');
        lineEndCol = this.text.slice(lineStartIndex).indexOf('\n');
      }
      if (this.seqEnd.col === this.seqStart.col || ((immNext === '\n' || immNext === void 0) && lineEndCol < this.seqStart.col)) {
        motion = wentForward ? "j" : "k";
        suggestCommand(distance, motion);
        return true;
      }
      return false;
    };

    KeyListener.prototype.suggestHomeEndMovement = function(next) {

      /*
      From the Vim documentation (online at http://vimdoc.sourceforge.net/htmldoc/motion.html#<Home>)
        0			  To the first character of the line. motion.
        ^			  To the first non-blank character of the line. motion.
        $       To the end of the line.
       */
      var fromLineStart, lineStart, stoppedAt;
      if (this.seqStart.line !== this.seqEnd.line) {
        return false;
      }
      if (this.seqEnd.col === 1) {
        suggestCommand(1, '0');
        return true;
      }
      if (next === '\n') {
        suggestCommand(1, '$');
        return true;
      }
      stoppedAt = this.text[this.seqEnd.index];
      if (stoppedAt != null ? stoppedAt.match(/^\S$/) : void 0) {
        lineStart = this.seqEnd.line === 1 ? 0 : 1 + this.text.slice(0, +this.seqEnd.index + 1 || 9e9).lastIndexOf('\n');
        fromLineStart = this.text.slice(lineStart, +(this.seqEnd.index - 1) + 1 || 9e9);
        if (fromLineStart.match(/^\s*$/)) {
          suggestCommand(1, '^');
          return true;
        }
      }
      return false;
    };

    KeyListener.prototype.suggestWordMovement = function(traversed, wentForward, beforeStart, last, next) {

      /*
      From the Vim documentation (online at http://vimdoc.sourceforge.net/htmldoc/motion.html#word-motions)
        4. Word motions
      
          w			[count] words forward. motion.
          W			[count] WORDS forward. motion.
          e			Forward to the end of word [count]. Does not stop in an empty line.
          E			Forward to the end of WORD [count]. Does not stop in an empty line.
          b			[count] words backward. motion.
          B			[count] WORDS backward. motion.
          ge	  Backward to the end of word [count].
          gE		Backward to the end of WORD [count].
      
          A word consists of a sequence of letters, digits and underscores, or a
          sequence of other non-blank characters, separated with white space (spaces,
          tabs, <EOL>).  This can be changed with the 'iskeyword' option.  An empty line
          is also considered to be a word.
      
          A WORD consists of a sequence of non-blank characters, separated with white
          space.  An empty line is also considered to be a WORD.
      
      eg:
      This "stuff" is not-so difficult!
      wwww  wwwww  ww www ww wwwwwwwww
      WWWW WWWWWWW WW WWWWWW WWWWWWWWWW
       */
      var count, motion, shouldBeWS, shouldNotBeWS;
      if (wentForward) {
        shouldBeWS = last;
        shouldNotBeWS = next;
      } else {
        shouldBeWS = next;
        shouldNotBeWS = last;
      }
      if (!(next === void 0 || (shouldBeWS.match(/^\s$/) && shouldNotBeWS.match(/^\S$/)))) {
        return false;
      }
      count = traversed.matchesOf(/\s+/) + traversed.occurrencesOf("\n\n");
      if (!wentForward && beforeStart !== void 0 && (beforeStart != null ? beforeStart.match(/\S/) : void 0)) {
        count++;
      }
      motion = wentForward ? "W" : "B";
      if (count > this.MAX_WORD_MOVEMENT_COUNT) {
        return false;
      }
      suggestCommand(count, motion);
      return true;
    };

    KeyListener.prototype.suggestAnchorMovement = function(traversed, wentForward) {

      /*
      From the Vim documentation (online at http://vimdoc.sourceforge.net/htmldoc/motion.html#word-motions)
        2. Left-right motions
      
        f{char}   To the [count]'th occurrence of {char} to the right. The cursor is placed on {char}.
        F{char}   To the [count]'th occurrence of {char} to the left.  The cursor is placed on {char}.
      
        t{char}   Till before [count]'th occurrence of {char} to the right. The cursor is placed on the character left of {char}.
        T{char}   Till after  [count]'th occurrence of {char} to the left.  The cursor is placed on the character right of {char}.
      
        eg:
        abc def?
        f?---->
        t?--->
      
        def? 123456
           <-----F?
            <----T?
      
        Remember: F can be for Find or Forward to
        We say an anchor is a defining element, one you can jump to, anchor to
       */
      var count, motion, next;
      next = this.text[this.seqEnd.index];
      count = traversed.occurrencesOf(next);
      if (wentForward && traversed[0] !== next) {
        count++;
      }
      motion = wentForward ? 'f' : 'F';
      if (count <= this.MAX_ANCHOR_MOVEMENT_COUNT) {
        suggestCommand(count, motion + next);
        return true;
      }
      return false;
    };

    return KeyListener;

  })();

  $(function() {
    var listener;
    loadSampleText();
    return listener = new KeyListener("#editor-text");
  });

  loadSampleText = function() {
    return $.ajax({
      url: "samples/fF and tT tests.txt",
      dataType: "text",
      success: function(data) {
        return $("#editor-text").text(data);
      }
    });
  };

  suggestCommand = function(count, motion) {
    return console.log("Suggestion:" + (count === 1 ? "" : count) + motion + ".");
  };

}).call(this);

//# sourceMappingURL=editor.js.map
