// Generated by CoffeeScript 1.10.0
(function() {
  var KeyListener, loadSampleText, suggestCommand,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Function.prototype.property = function(prop, desc) {
    return Object.defineProperty(this.prototype, prop, desc);
  };

  String.prototype.occurrencesOf = function(substr) {
    var i, j, occ, ref;
    occ = 0;
    for (i = j = 0, ref = this.length - substr.length; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      if (this.slice(i).startsWith(substr)) {
        occ++;
      }
    }
    return occ;
  };

  String.prototype.matchesOf = function(regex) {
    var match, source;
    source = regex.source;
    regex = new RegExp(source, "g");
    match = this.match(regex);
    if (match != null) {
      return match.length;
    }
    return 0;
  };

  Array.prototype.containsOnly = function(targets) {
    var elem, j, len;
    for (j = 0, len = this.length; j < len; j++) {
      elem = this[j];
      if (!_.contains(targets, elem)) {
        return false;
      }
    }
    return true;
  };

  Array.prototype.contains = function(target) {
    return _.contains(this, target);
  };

  this.Keys = {
    left: 37,
    right: 39,
    up: 38,
    down: 40,
    mouse: -1
  };

  Keys.directional = [Keys.left, Keys.right, Keys.up, Keys.down, Keys.mouse];

  KeyListener = (function() {
    KeyListener.prototype.MAX_TIME_BETWEEN_STROKES = 750;

    KeyListener.prototype.MIN_MOVEMENT_STROKES = 3;

    KeyListener.prototype.MAX_MOVEMENT_COUNT = 5;

    KeyListener.property('seqStart', {
      set: function(index) {
        return this._seqStartIndex = index;
      },
      get: function() {
        var lineCol, textToCursor;
        textToCursor = this.elem.text().slice(0, this._seqStartIndex);
        lineCol = this.computeLineCol(textToCursor, this._seqStartIndex);
        return $.extend({
          index: this._seqStartIndex
        }, lineCol);
      }
    });

    KeyListener.property('seqEnd', {
      set: function(index) {
        return this._seqEndIndex = index;
      },
      get: function() {
        var lineCol, textToCursor;
        textToCursor = this.elem.text().slice(0, this._seqEndIndex);
        lineCol = this.computeLineCol(textToCursor, this._seqEndIndex);
        return $.extend({
          index: this._seqEndIndex
        }, lineCol);
      }
    });

    KeyListener.prototype.computeLineCol = function(str, index) {
      var startOfLine;
      startOfLine = str.lastIndexOf('\n');
      return {
        line: 1 + str.occurrencesOf('\n'),
        col: index - startOfLine
      };
    };

    KeyListener.property('elem', {
      get: function() {
        return $(this.selector);
      }
    });

    KeyListener.property('htmlElem', {
      get: function() {
        return this.elem[0];
      }
    });

    function KeyListener(selector) {
      var code, name, self;
      this.selector = selector;
      self = this;
      this.elem.keydown(function() {
        return self.registerKeyDown(event.which);
      }).keyup(function() {
        return self.registerKeyUp(event.which);
      }).mousedown(function() {
        return self.registerMouseDown();
      }).mouseup(function() {
        return self.registerMouseUp();
      });
      this.supportedKeyCodes = [];
      for (name in Keys) {
        code = Keys[name];
        this.supportedKeyCodes.push(code);
      }
      this.currSeq = [];
    }

    KeyListener.prototype.registerKeyDown = function(code) {
      if (indexOf.call(this.supportedKeyCodes, code) < 0) {
        return;
      }
      return this.registerPossibleStart();
    };

    KeyListener.prototype.registerKeyUp = function(code) {
      if (indexOf.call(this.supportedKeyCodes, code) < 0) {
        return;
      }
      this.registerEnd();
      this.currSeq.push(code);
      if (this.timer != null) {
        clearTimeout(this.timer);
      }
      return this.timer = setTimeout(this.processSeq.bind(this), this.MAX_TIME_BETWEEN_STROKES);
    };

    KeyListener.prototype.registerPossibleStart = function() {
      if (this.currSeq.length === 0) {
        return this.seqStart = this.htmlElem.selectionStart;
      }
    };

    KeyListener.prototype.registerEnd = function() {
      return this.seqEnd = this.htmlElem.selectionStart;
    };

    KeyListener.prototype.registerMouseDown = function() {
      return this.registerPossibleStart();
    };

    KeyListener.prototype.registerMouseUp = function() {
      this.registerEnd();
      this.currSeq.push(Keys.mouse);
      return this.processSeq();
    };

    KeyListener.prototype.processSeq = function() {
      var beforeStart, count, from, last, motion, next, shouldBeWS, shouldNotBeWS, text, to, traversed, wentForward;
      text = this.elem.text();
      wentForward = this.seqEnd.index - this.seqStart.index > 0;
      if (this.seqStart.index === this.seqEnd.index) {
        traversed = '';
      } else {
        if (wentForward) {
          from = this.seqStart.index;
          to = this.seqEnd.index;
        } else {
          from = this.seqEnd.index;
          to = this.seqStart.index;
        }
        traversed = text.slice(from, +(to - 1) + 1 || 9e9);
      }

      /*
      When traversing 'abcd' from left to right -->, the letter we stopped at is 'd'
      But traversing it the other way, right to left <--, the letter we stopped at is 'a'
      Same goes for the next char: on left to right direction, the next char is the one to the right of d
      But on right to left direction, the next char is the one before a
       */
      beforeStart = text[this.seqStart.index - 1];
      last = wentForward ? traversed.slice(-1) : traversed[0];
      next = wentForward ? text[this.seqEnd.index] : text[this.seqEnd.index - 1];

      /*
      From the Vim documentation (online at http://vimdoc.sourceforge.net/htmldoc/motion.html#word-motions)
        4. Word motions
      
          w			[count] words forward.  |exclusive| motion.
          W			[count] WORDS forward.  |exclusive| motion.
          e			Forward to the end of word [count] |inclusive|. Does not stop in an empty line.
          E			Forward to the end of WORD [count] |inclusive|. Does not stop in an empty line.
          b			[count] words backward.  |exclusive| motion.
          B			[count] WORDS backward.  |exclusive| motion.
          ge	  Backward to the end of word [count] |inclusive|.
          gE		Backward to the end of WORD [count] |inclusive|.
      
          A word consists of a sequence of letters, digits and underscores, or a
          sequence of other non-blank characters, separated with white space (spaces,
          tabs, <EOL>).  This can be changed with the 'iskeyword' option.  An empty line
          is also considered to be a word.
      
          A WORD consists of a sequence of non-blank characters, separated with white
          space.  An empty line is also considered to be a WORD.
      
      eg:
      This "stuff" is not-so difficult!
      wwww  wwwww  ww www ww wwwwwwwww
      WWWW WWWWWWW WW WWWWWW WWWWWWWWWW
       */
      if (this.currSeq.containsOnly(Keys.directional)) {
        if ((this.currSeq.contains(Keys.mouse) && traversed.length > 0) || (traversed.length >= this.MIN_MOVEMENT_STROKES && this.currSeq.length >= this.MIN_MOVEMENT_STROKES)) {
          if (wentForward) {
            shouldBeWS = last;
            shouldNotBeWS = next;
          } else {
            shouldBeWS = next;
            shouldNotBeWS = last;
          }
          if (next === void 0 || (shouldBeWS.match(/\s/) && shouldNotBeWS.match(/\S/))) {
            count = traversed.matchesOf(/\s+/) + traversed.occurrencesOf("\n\n");
            if (!wentForward && beforeStart !== void 0 && (beforeStart != null ? beforeStart.match(/\S/) : void 0)) {
              count++;
            }
            motion = wentForward ? "W" : "B";
            if (count <= this.MAX_MOVEMENT_COUNT) {
              suggestCommand(count, motion);
            }
          }
        }
      }
      this.currSeq = [];
      return this.timer = null;
    };

    return KeyListener;

  })();

  $(function() {
    var listener;
    loadSampleText();
    return listener = new KeyListener("#editor-text");
  });

  loadSampleText = function() {
    return $.ajax({
      url: "samples/^ $ 0 tests.txt",
      dataType: "text",
      success: function(data) {
        return $("#editor-text").text(data);
      }
    });
  };

  suggestCommand = function(count, motion) {
    return console.log("Suggestion: " + (count > 1 ? count : "") + motion);
  };

}).call(this);

//# sourceMappingURL=editor.js.map
